  <div class="container bg-3 text-left">
    <h3>Week1</h3>  
  </div>

  <div class=empty-row-1> </div>

  <div class="container bg-3 text-left">
  	<h4>Tuesday</h4>
  	<h5>l-value and r-value references</h5>
  </div>
  <div class="container bg-3 text-left">
  		<pre class="prettyprint lang-cpp">
#include < iostream >
#include < time.h >

using namespace std;

class Wow{
public:
    //constructor
    Wow(int size){
        cout << "default constructor\n";
        size_ = size;
        list_ = new int[size_];
    }

    // copy constructor: l-value
    Wow(const Wow& other){
        cout << "copy constructor\n";
        size_ = other.size_;
        list_ = new int[size_];
        for(int i=0;i < size_;++i) list_[i] = other.list_[i];
    }

    // move constructor: r-value
    Wow(Wow&& other){
        cout << "move constructor\n";
        size_ = other.size_;
        list_ = other.list_;
        other.size_ = 0;
        other.list_ = nullptr;
    }

    // assignment operator
    // Wow& other: you are expecting a l-value. If you give r-value, you will get an error.
    // Fix: use const.
    Wow& operator=(const Wow& other){
        cout << "assignment\n";

        // if other is itself
        if(this == &other) return *this;

        // if other is something else
        delete[] list_;
        size_ = other.size_;
        list_ = new int[size_];
        for(int i=0;i < size_;++i) list_[i] = other.list_[i];

        return *this;
    }

    // move assignment
    Wow& operator=(Wow&& other){ // r-value reference
        cout << "move\n";

        if(this == &other) return *this;

        delete[] list_;
        size_ = other.size_;
        list_ = other.list_;

        other.list_ = nullptr;
        other.size_ = 0;

        return* this;
    }

    // destructor
    ~Wow(){
        delete[] list_;
    }
// private:
    int  size_;
    int* list_; // list of integers in heap
};

// create r-value
Wow create_wow_object(int size){
    return Wow(size);
}

int main(){

    clock_t t;

    t = clock();
    Wow A = create_wow_object(1000000000); // A: l-value
    Wow B(std::move(A)); // copy constructor move: A l-value -> r-value

    printf("A: %d\n", A.size_);

    printf("time: %5.2e seconds\n", ((float) clock() -t)/CLOCKS_PER_SEC);

}

    	</pre>
  </div>

  <div class=empty-row-1> </div>


  <div class="container bg-3 text-left">
    <h4>Thursday</h4>
    <h5>Notes on HW1</h5>
    <p> Note that the code below is far from complete. </p>
    <p> Please finish the codes by following Professor's coding practice and correct commenting styles. </p>
  </div>
  <div class="container bg-3 text-left">
        <pre class="prettyprint lang-cpp">
/**

    This codes will provide you a jump start for the homework 1. 
    Most of the codes are from Professor's lecture videos and PIC10B notes.

**/

#ifndef __MAX_HEAP_H__
#define __MAX_HEAP_H__

#include < iostream >

#include < string >
#include < iostream >
#include < vector >

namespace pic10c{
template< typename T, typename CallableType = std::less< T > > 

class max_heap{
private:
    std::vector< T > values; // vector contatining the variable type T. If T is int then values is a vector of integers.
    CallableType pred; // means of comparison. The default will be less = '<'.

public:
    // constructor.
    max_heap(const CallableType& _pred = CallableType() ) noexcept: pred(_pred) {}

    // insert function for r value. T&& is a r-value reference.
    void insert(T&& other) {
        // TODO
    }

    // insert function for l value.
    void insert(const T& other) {
        // TODO
    }
    
    // size will return the number of iterms in 'values'.
    // There are two size() functions: one from max_heap class and the other from vector class.
    // If you use just size() then you are using the size() function from max_heap class.
    // If you use asdf.size() where 'asdf' is a vector object, then size() is from vector class.
    int size() const {
        return values.size();
    }

    // This part you are throwing an logic error if there is nothing to pop out.
    // Check 'Data Structure' PIC10B note to learn about throwing exceptions.
    void pop(){
        if(size() == 0) throw std::logic_error("Pop empty");
        values.pop_back();
    }

    const T& top(){
        // TODO
    }

    template< typename... Args >
    void emplace(Args&&... value){
        // TODO: Finish the function
        // it can be done in a single line. The line may contain "T(std::forward< Args >(value)...)".
        // "T(std::forward< Args >(value)...)" expands 'value' maintaining the data types of parameters.
        // For example, if you use emplace(10,'c'), then std::forward< Args >(valu)... will expand the parameters to
        // int 10, char 'c'. 
        // ----- Write your code below -----


    }
}; // class max_heap
}

#endif
        </pre>
  </div>

  <div class=empty-row-1> </div>

  